//==================================================================-*-C++-*-=
// File:        XML.g
// Description: The parser of XML structures generated by Sigma as query or 
//              assertion that are send to Vompire .
//              The grammar is written for ANTLR parser generator.
// Part of:     
// Status:      
// Created:     Jul 09, 2002, Andrey Chaltsev, chaltsev@cs.man.ac.uk
// Doc:         
// Compliance:
// Reviewed:    
//              
// Revised:     
//              
// Note:        
//============================================================================


header 
{
  // head of lexer file
#include <iostream>
#include "Query.hpp"
}

options { language="Cpp"; }

class XMLLexer extends Lexer;
options
{ 
	k=3;
	charVocabulary = '\u0000'..'\u00FF'; // 8 bits character
  importVocab=KIFLexer;
  defaultErrorHandler=false;
}

// simplified version of letters - only english alphabet
protected
LETTER : 'A' .. 'Z'  |  'a' .. 'z'
;

// simplified version of digit - only 0 - 9
protected
DIGIT : '0' .. '9'
;

// simplified version of name
NAME :  ( LETTER | '_' | ':')
        ( LETTER | '_' | ':' | '.' | '-' | DIGIT )*
;




START_TAG         options { paraphrase = "<";  } : "<" ;
START_OF_END_TAG  options { paraphrase = "</"; } : "</";
END_OF_TAG        options { paraphrase = ">";  } : '>';
END_OF_EMPTY_TAG  options { paraphrase = "/>"; } : "/>";
EQ                options { paraphrase = "=";  } : '=';

// simplified version of string ( any characters in "s or in 's)
STRING
    :   '"'!    
        (  (~( '"' | '\n' ))
        |  ( '\n'  {newline();} )
        )*
        '"'!

    |   '\''!
        ( (~( '\'' | '\n' ))
        | ( '\n' {newline();} )
        )*
        '\''!
;


// skip rules : comments and white characters

// comments. skip it. May be not . I think ...
COMMENT
        :  "<!--"
           // here ANTLR generates warning, but this is correct rule
           (   { (LA(2) != '-' || LA(3) != '>') }? '-' 
           |   ( '\n'    { newline(); } )
           |   ~( '-' | '\n' )
           )*
           "-->"          { _ttype = ANTLR_USE_NAMESPACE(antlr)Token::SKIP; }
;
           
// skip white characters.
WHITE :	    ( ' ' | '\t' | '\r' | ( '\n' {newline();}) | '\f' )
                           { _ttype = ANTLR_USE_NAMESPACE(antlr)Token::SKIP; }
;


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//                           PARSER
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

{
  // head of parser file
#include "KIFParser.hpp"

#include "antlr/TokenStreamSelector.hpp"
extern antlr::TokenStreamSelector* selector;

}

// very simplified XML Parser to parse Sigma query to Vampire
class XMLParser extends Parser;
options 
{
  k=2;
  defaultErrorHandler=false;
}
// it is added into body of class XMLParser
{
}

// first rule to be invoked
// start
// returns [bool b]
//   {
//   } 
//  :
//    query_or_assertion_plus  EOF                   { b = true; }
// ;

// non-empty sequence of queries or assertions
// query_or_assertion_plus :
//    ( query | assertion ) 
//    ( query_or_assertion_plus )?
//  ;

start
  returns [Query* q]
  :
  q = query
  |
  q = assertion
  |
  terminate
        {
	  q = new Query ();
	}
;

terminate
  :
  START_TAG 
  kw_bye 
  END_OF_EMPTY_TAG
  |
  EOF
  ;


query 
  returns [Query* query]
        {
	  Query::Attribute* attrs;
	  Formula formula;
	}
  :
   START_TAG kw_query
   attrs = attributes
   END_OF_TAG
   {                   //  !!! KIF parser invocation !!!
     // switch lexers
     selector->push("KIFLexer");
     // create a parser to handle the KIF structures
     KIFParser kifParser (getInputState());
     kifParser.sentence(formula); // go parse KIF
     // switch lexers back
     selector->pop();
     query = new Query (Query::GOAL, formula, attrs);
   }    
   START_OF_END_TAG   kw_query  END_OF_TAG
;

assertion 
  returns [Query* query]
        {
	  Query::Attribute* attrs;
	  Formula formula;
	}
  :
   START_TAG kw_assertion
   attrs = attributes
   END_OF_TAG
   {                   //  !!! KIF parser invocation !!!
     // switch lexers
     selector->push("KIFLexer");
     // create a parser to handle the KIF structures
     KIFParser kifParser (getInputState());
     kifParser.sentence(formula); // go parse KIF
     // switch lexers back
     selector->pop();
     query = new Query (Query::ASSERTION, formula, attrs);
   }    
   START_OF_END_TAG   kw_assertion  END_OF_TAG
;


// attributes are non-empty list of pairs string-string (name-value)
attributes 
  returns [Query::Attribute* attrs]
        {
	  Query::Attribute* rest = 0;
	}
  :
     attrs = attribute 
     rest = attributes 
        {
	  attrs->next (rest);
	}
     |
        {
	  attrs = 0;
	}
;


attribute
  returns [Query::Attribute* attr]
  :
   n: NAME
   EQ
   st:STRING
        {
	  attr = new Query::Attribute ( n->getText(), st->getText());
	}
;


recover
:
  (START_OF_END_TAG | )
  (kw_assertion | kw_query)
  END_OF_TAG
;

//------------------   KEYWORDS  ---------------------------------------

kw_query       : "query"     ;
kw_assertion   : "assertion" ;
kw_bye         : "bye";
