//
// File:         ForwardMatchingIndexTree.hpp
// Description:  Code trees for matching.
// Created:      Feb 15, 2000, 15:20
// Revised:      Jan 10, 2001
// Revised:      Jan 22, 2001 (made generic) 
// Author:       Alexandre Riazanov
// mail:         riazanov@cs.man.ac.uk
// Note:         This is a part of the Gematogen library. 
//====================================================
#ifndef FORWARD_MATCHING_INDEX_TREE_H
//====================================================
#define FORWARD_MATCHING_INDEX_TREE_H
#ifndef NO_DEBUG_VIS 
#include <iostream>
#endif
#include <climits>
#include "jargon.hpp"
#ifdef _SUPPRESS_WARNINGS_
#include "RuntimeError.hpp"
#endif
#include "GlobalStopFlag.hpp"
#include "GematogenDebugFlags.hpp"
#include "Stack.hpp"
#include "EquivalenceRelation.hpp"
#include "MultisetOfVariables.hpp"
#include "DestructionMode.hpp"
#include "RuntimeError.hpp"
using namespace std;
//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>"
#endif
#include "debugMacros.hpp"
//=================================================


namespace Gem
{
  template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
  class FMCodeTree
  {
  public:
    class Instruction;
    class Leaf;
    class Integrator;
    class Removal;
    class Retrieval;
    class Output;
 public:
  static void Destroy(Instruction* tree);  
  static void DestroyBranch(Instruction** branch);
  }; // class FMCodeTree
}; // namespace Gem



//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction"
#endif
#include "debugMacros.hpp"
//=================================================


namespace Gem
{

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction
{
 public:
  enum Tag 
  { 
    FuncTag, 
    VarTag, 
    CompareTag, 
    LeafTag 
  };
 public:
  Instruction(Tag t)  : _tag(t)
    {
    };
  ~Instruction() 
    {
      CALL("destructor ~Instruction()");
      if (isLeaf())
	{
	  leafInfo().destroy();
	};
    };
  

  void* operator new(size_t,size_t size)
    {
      return Alloc::allocate(size);
    };  // void* operator new(size_t,size_t size)
  
  void operator delete(void* obj,size_t size)
  { 
    CALL("operator delete(void* obj,size_t size)");
    Alloc::deallocate(obj,size); 
  }; // void operator delete(void* obj,size_t size)

  void operator delete(void* obj)
    { 
      CALL("operator delete(void* obj)");
      switch ((static_cast<Instruction*>(obj))->_tag)  
	{
	case FuncTag: Alloc::deallocate(obj,sizeof(TagAndNextAndForkAndSymbol)); break;
	case VarTag: Alloc::deallocate(obj,sizeof(TagAndNextAndForkAndVar)); break;
	case CompareTag: Alloc::deallocate(obj,sizeof(TagAndNextAndForkAndVar1AndVar2)); break;
	case LeafTag: Alloc::deallocate(obj,sizeof(TagAndLeafInfo)); break;
#ifdef DEBUG_NAMESPACE
	default: ICP("0");   
#else
#  ifdef _SUPPRESS_WARNINGS_
	default: BK::RuntimeError::report("ICP in FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::delete(void* obj)");
#  endif             
#endif
	}; 
    }; // void operator delete(void* obj)


  
  Tag tag() const 
    {
      CALL("tag()");      
      return _tag; 
    };

  bool isFunc() const 
    {
      CALL("isFunc() const"); 
      return (_tag == FuncTag); 
    };

  /***
  bool isVar() const 
    {
      CALL("isVar() const");
      return (_tag == VarTag); 
    };
  ***/

  bool isCompare() const 
    {
      CALL("isCompare() const"); 
      return (_tag == CompareTag); 
    };
  bool isLeaf() const 
    {
      CALL("isLeaf() const");
      return (_tag == LeafTag); 
    };    
 
  Instruction** nextAddr() 
    { 
      CALL("nextAddr()");
      ASSERT(_tag != LeafTag);
      return 
	static_cast<Instruction**>(static_cast<void*>((static_cast<OnlyTag*>(static_cast<void*>(this))) + 1)); 
    };
  Instruction* const * nextAddr() const 
    {
      CALL("nextAddr() const"); 
      return 
	static_cast<Instruction* const *>(static_cast<const  void*>((static_cast<const OnlyTag*>(static_cast<const void*>(this))) + 1)); 
    };
  Instruction* next() const { return *(nextAddr()); };
  void setNext(Instruction* n) { *(nextAddr()) = n;  };

  Instruction** forkAddr() 
    { 
      CALL("forkAddr()");
      ASSERT(_tag != LeafTag);
      return static_cast<Instruction**>(static_cast<void*>((static_cast<TagAndNext*>(static_cast<void*>(this))) + 1)); 
    };
  Instruction* const * forkAddr() const 
    {
      CALL("forkAddr() const");
      ASSERT(_tag != LeafTag); 
      return static_cast<Instruction* const *>(static_cast<const void*>((static_cast<const TagAndNext*>(static_cast<const void*>(this))) + 1)); 
    }; 
  Instruction* fork() const 
  {
    CALL("fork() const");
    return *(forkAddr()); 
  };     
  void setFork(Instruction* f) { *(forkAddr()) = f; };

  // Methods for Func:

  
  Symbol* funcAddr() 
    {
      CALL("funcAddr()");
      return 
	static_cast<Symbol*>(static_cast<void*>((static_cast<TagAndNextAndFork*>(static_cast<void*>(this))) + 1)); 
    };
  const Symbol* funcAddr() const 
    {
      CALL("funcAddr() const"); 
      return 
	static_cast<const Symbol*>(static_cast<const void*>((static_cast<const TagAndNextAndFork*>(static_cast<const void*>(this))) + 1)); 
    };
  

  const Symbol& func() const { return *(funcAddr()); };
  void setFunc(const Symbol& f) 
    { 
      *(funcAddr()) = f; 
    };
  static Instruction* newFunc(const Symbol& f)
    {
      Instruction* res = new (sizeof(TagAndNextAndForkAndSymbol)) Instruction(FuncTag);
      res->setFunc(f);
      res->setNext(0);
      res->setFork(0);
      return res;
    };

  // Methods for Var:
  const Flatterm*** varAddr() 
    {
      CALL("varAddr()");
      return static_cast<const Flatterm***>(static_cast<void*>((static_cast<TagAndNextAndFork*>(static_cast<void*>(this))) + 1)); 
    };
  const Flatterm** const * varAddr() const 
    {
      CALL("varAddr() const"); 
      return 
	static_cast<const Flatterm** const *>(static_cast<const void*>((static_cast<const TagAndNextAndFork*>(static_cast<const void*>(this))) + 1)); 
    };
  const Flatterm** var() const { return *(varAddr()); };
  void setVar(const Flatterm** v) { *(varAddr()) = v; };      
  static Instruction* newVar(const Flatterm** v)
    {
      Instruction* res = new (sizeof(TagAndNextAndForkAndVar)) Instruction(VarTag);
      res->setVar(v);
      res->setNext(0);
      res->setFork(0);
      return res;
    };

  // Methods for Compare:
  const Flatterm*** var1Addr() 
    {
      CALL("var1Addr()"); 
      return static_cast<const Flatterm***>(static_cast<void*>((static_cast<TagAndNextAndFork*>(static_cast<void*>(this))) + 1)); 
    };
  const Flatterm** const * var1Addr() const 
    {
      CALL("var1Addr() const");  
      return 
	static_cast<const Flatterm** const *>(static_cast<const void*>((static_cast<const TagAndNextAndFork*>(static_cast<const void*>(this))) + 1)); 
    };
  const Flatterm** var1() const { return *(var1Addr()); };
  void setVar1(const Flatterm** v) { *(var1Addr()) = v; };    

  const Flatterm*** var2Addr() 
    {
      CALL("var2Addr()"); 
      return 
	static_cast<const Flatterm***>(static_cast<void*>((static_cast<TagAndNextAndForkAndVar1*>(static_cast<void*>(this))) + 1));
    };
  const Flatterm** const * var2Addr() const 
    {    
      CALL("var2Addr() const");  
      return 
	static_cast<const Flatterm** const *>(static_cast<const void*>((static_cast<const TagAndNextAndForkAndVar1*>(static_cast<const void*>(this))) + 1));
    };
  const Flatterm** var2() const { return *(var2Addr()); };
  void setVar2(const Flatterm** v) { *(var2Addr()) = v; };

  void bothVars(const Flatterm**& v1,const Flatterm**& v2) 
    {
      CALL("bothVars(const Flatterm**& v1,const Flatterm**& v2)"); 
      v1 = var1(); 
      v2 = var2(); 
    };
  static Instruction* newCompare(const Flatterm** v1,const Flatterm** v2)
    {
      CALL("newCompare(const Flatterm** v1,const Flatterm** v2)");
      ASSERT(v1 < v2);
      Instruction* res = new (sizeof(TagAndNextAndForkAndVar1AndVar2)) Instruction(CompareTag);
      res->setVar1(v1);
      res->setVar2(v2);
      res->setNext(0);
      res->setFork(0);
      return res;
    }; 

  // Methods for Leaf:
  LeafInfo* leafInfoAddr() 
    {
      CALL("leafInfoAddr()");
      return static_cast<LeafInfo*>(static_cast<void*>((static_cast<OnlyTag*>(static_cast<void*>(this))) + 1)); 
    };     
  const LeafInfo* leafInfoAddr() const  
    {
      CALL("leafInfoAddr() const");
      return 
	static_cast<const LeafInfo*>(static_cast<const void*>((static_cast<const OnlyTag*>(static_cast<const void*>(this))) + 1)); 
    };    
  LeafInfo& leafInfo() 
    {
      CALL("leafInfo()");
      return *(leafInfoAddr()); 
    }; 
  const LeafInfo& leafInfo() const
    {
      CALL("leafInfo() const");
      return *(leafInfoAddr()); 
    }; 


  static Instruction* newLeaf()
    {
      Instruction* res = new (sizeof(TagAndLeafInfo)) Instruction(LeafTag);
      return res;
    };

 public:
#ifndef NO_DEBUG_VIS 
  ostream& output(ostream& str,const Flatterm* const * subst) const;
#endif




 private: // size templates
  class OnlyTag
    {
    private: 
      Tag _tag;
    };
  class TagAndNext
    {
    private: 
      Tag _tag;
      Instruction* _next;
    };

  class TagAndNextAndFork
    {
    private: 
      Tag _tag;
      Instruction* _next;
      Instruction* _fork;   
    }; 

  class TagAndNextAndForkAndSymbol // Func
    {
    private: 
      Tag _tag;
      Instruction* _next;
      Instruction* _fork;   
      Symbol _sym;
    }; 
  class TagAndNextAndForkAndVar // Var
    {
    private: 
      Tag _tag;
      Instruction* _next;
      Instruction* _fork; 
      const Flatterm** _var;
    };

  class TagAndNextAndForkAndVar1
    {
    private: 
      Tag _tag;
      Instruction* _next;
      Instruction* _fork; 
      const Flatterm** _var1;
    };

  class TagAndNextAndForkAndVar1AndVar2 // Compare
    {
    private: 
      Tag _tag;
      Instruction* _next;
      Instruction* _fork; 
      const Flatterm** _var1;
      const Flatterm** _var2;
    };

  class TagAndLeafInfo // Leaf
    {
    private: 
      Tag _tag;
      LeafInfo _leafInfo;
    };


 private: // data
  Tag _tag;
   
}; // template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> class Instruction

}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Leaf"
#endif
#include "debugMacros.hpp"
//=================================================

namespace Gem
{

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Leaf : private FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction
{
 public:
  Leaf() {};
  LeafInfo* leafInfoAddr() { return FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::leafInfoAddr(); };
  LeafInfo& leafInfo() { return FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::leafInfo(); };

#ifndef NO_DEBUG
  bool isLeaf() const { return FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::isLeaf(); };
#endif 

}; // template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> class FMCodeTree<..>::Leaf


}; // namespace Gem




//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator"
#endif 
#include "debugMacros.hpp"
//=================================================
namespace Gem
{

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator // objects must be static - too costly constructor
{
 public:
  Integrator(const Flatterm** subst)
    : _constrToInsert("Integrator::_constrToInsert"),
    _constrToShift("Integrator::_constrToShift"),
    _constrPassed("Integrator::_constrPassed"),
    _constrPassedInShift("Integrator::_constrPassedInShift"),
    _constrIntegrated("Integrator::_constrIntegrated"),
    _constrOld("Integrator::_constrOld"),
    _matchingIndexSubstitution(subst),
    _registeredVariables() 
  {
    CALL("constructor Integrator(const Flatterm** subst)");
  };

  ~Integrator() 
  {
    CALL("destructor ~Integrator()");
  };

  void init(const Flatterm** subst)
  {
    CALL("init(const Flatterm** subst)");
    _constrToInsert.init("_constrToInsert");
    _constrToShift.init("_constrToShift");
    _constrPassed.init("_constrPassed");
    _constrPassedInShift.init("_constrPassedInShift");
    _constrIntegrated.init("_constrIntegrated");
    _constrOld.init("_constrOld");
    _matchingIndexSubstitution = subst;
    _registeredVariables.init();
  }; // void init(const Flatterm** subst)

  void destroy()
  {
    CALL("destroy()");
    _registeredVariables.destroy();
    _constrOld.destroy();
    _constrIntegrated.destroy();
    _constrPassedInShift.destroy();
    _constrPassed.destroy();
    _constrToShift.destroy();
    _constrToInsert.destroy();
    BK_CORRUPT(*this);
  }; // void destroy()


  void Reset(Instruction** n)
    {
      _nodeAddr = n;
      _constrToInsert.Reset();
      _constrToShift.Reset();
      _constrPassed.Reset();
      //_constrPassedInShift.Reset();
      _constrIntegrated.Reset();
      _constrOld.Reset();
      _registeredVariables.Reset();
      _currentMatchingIndexVar = _matchingIndexSubstitution;
      _readModeFlag = ((*_nodeAddr) != 0);
    };

  BK::MultisetOfVariables<MaxNumOfVariables>& Vars() { return _registeredVariables; };

  const Flatterm** MapVar(ulong v) const { return _firstVariableOccurence[v]; }; 

  void Push(const Symbol& sym)
    { 
      if (sym.isVariable()) { PushVar(sym); } else PushFunc(sym); 
    };  
  void PushVar(const Symbol& sym);
  void PushFunc(const Symbol& sym);

  Leaf* GetLeaf(bool& newLeaf)
    {
      CALL("GetLeaf()");
      _readModeFlag = _readModeFlag && ReadCollectedComps(); 
      newLeaf = !_readModeFlag;       
      if (_readModeFlag) 
	{
	  ASSERT((*_nodeAddr)->isLeaf());
	  return static_cast<Leaf*>(static_cast<void*>(*_nodeAddr));
	};
      // write mode
      *_nodeAddr = Instruction::newLeaf();
      return static_cast<Leaf*>(static_cast<void*>(*_nodeAddr));
    };
 
 private: 
  typedef BK::EquivalenceRelation<MaxTermSize> EqualityConstraint;

 private:
  void MoveDown() { _nodeAddr = (*_nodeAddr)->nextAddr(); };
  void MoveRight() { _nodeAddr = (*_nodeAddr)->forkAddr(); };
  ulong VarNum(const Flatterm** v) const { return v - _matchingIndexSubstitution; };
  const Flatterm** Var(const ulong& var_num) const 
    {
      CALL("Var(ulong var_num) const");
      ASSERT(var_num < MaxTermSize); 
      return _matchingIndexSubstitution + var_num; 
    };
#ifdef DEBUG_NAMESPACE
  bool debugInSubst(const Flatterm** var) const 
    { 
      return (var >= _matchingIndexSubstitution) && (var < (_matchingIndexSubstitution + MaxTermSize));
    }; 
#endif

  void MakeShifted(const ulong& v1,const ulong& v2) 
    {
      CALL("MakeShifted(const ulong& v1,const ulong& v2)");
      ASSERT(v1 < v2);
      ASSERT(!_constrIntegrated.Equivalent(v1,v2));
      _constrToShift.MakeEquivalent(v1,v2);
    };

  void MakeIntegrated(const ulong& v1,const ulong& v2) 
    {
      CALL("MakeIntegrated(const ulong& v1,const ulong& v2)");
      ASSERT(v1 < v2);
      ASSERT(!_constrIntegrated.Equivalent(v1,v2));
      ASSERT(!_constrPassed.Equivalent(v1,v2));
      ASSERT(!_constrOld.Equivalent(v1,v2));
      _constrIntegrated.MakeEquivalent(v1,v2);
    };    

#ifdef DEBUG_NAMESPACE
  void CheckConstrIntegrity()
    { 
      CALL("CheckConstrIntegrity()");
      ASSERT(_constrToInsert.Implies(_constrIntegrated));      
      ASSERT(_constrPassed.Implies(_constrIntegrated));   
      ASSERT(_constrToShift.Implies(_constrOld));        
      ASSERT(_constrPassed.Implies(_constrOld));
      static EqualityConstraint debugER("debugER");  
      debugER.MakeComposition(_constrToShift,_constrPassed);
      ASSERT(_constrOld.Implies(debugER));
      debugER.MakeComposition(_constrToInsert,_constrPassed);
      ASSERT(_constrIntegrated.Implies(debugER));
    }; //void CheckConstrIntegrity() 
#endif 



  void PassCompNF(Instruction* instr)
    {
      // Trying to pass a Compare having no fork
      CALL("PassCompNF(Instruction* instr)");
      DOP(CheckConstrIntegrity());
      ASSERT(instr->isCompare());
      const Flatterm** var1 = instr->var1();
      const Flatterm** var2 = instr->var2();
      const ulong var_num1 = VarNum(var1);
      const ulong var_num2 = VarNum(var2);

      ASSERT(!(instr->fork()));
      ASSERT(!_constrToShift.Equivalent(var_num1,var_num2));
      ASSERT(!_constrOld.Equivalent(var_num1,var_num2));
      ASSERT(!_constrPassed.Equivalent(var_num1,var_num2));
   
      bool shared = _constrIntegrated.Equivalent(var_num1,var_num2);
    
      if (shared)
	{
	  // the current instruction is shared
	  _constrPassed.MakeEquivalent(var_num1,var_num2);
	  _nodeAddr = instr->nextAddr();
	}
      else // ! _constrIntegrated.Equivalent(var_num1,var_num2)
	{
	  // the instruction itself must be shifted unless it can be replaced by an equivalent one 
	  *_nodeAddr = instr->next();
	  delete instr;
	};

      instr = *_nodeAddr;
      EqualityConstraint::MergedPairs mergedPairs(_constrOld,var_num1,var_num2);
      ulong merged1;
      ulong merged2;

      while (mergedPairs.nextPair(merged1,merged2))
	{
	  ASSERT(merged1 < merged2);     
	  ASSERT(!_constrOld.Equivalent(merged1,merged2));
	  if (_constrIntegrated.Equivalent(merged1,merged2) && (!_constrPassed.Equivalent(merged1,merged2)))
	    {
	      // another Compare can be shared	 
	      shared = true;
	      _constrPassed.MakeEquivalent(merged1,merged2);
	      *_nodeAddr = Instruction::newCompare(Var(merged1),Var(merged2));
	      (*_nodeAddr)->setNext(instr);
	      MoveDown();
	    };
	};    
  
      _constrOld.MakeEquivalent(var_num1,var_num2);
      if (!shared) MakeShifted(var_num1,var_num2);
      ASSERT((*_nodeAddr) == instr);
      DOP(CheckConstrIntegrity());
    }; // void PassCompNF(Instruction* instr) 

  bool PassComp(Instruction* instr)
    {
      // Trying to pass a Compare instruction that might have fork
      CALL("PassComp(Instruction* instr)");
      DOP(CheckConstrIntegrity()); 
      ASSERT(instr->isCompare());
      const Flatterm** var1 = instr->var1();
      const Flatterm** var2 = instr->var2();
      ulong var_num1 = VarNum(var1);
      ulong var_num2 = VarNum(var2);
      ASSERT(!_constrToShift.Equivalent(var_num1,var_num2));
      ASSERT(!_constrOld.Equivalent(var_num1,var_num2)); 
      ASSERT(!_constrPassed.Equivalent(var_num1,var_num2));

      ASSERT((*_nodeAddr) == instr);

      if (_constrIntegrated.Equivalent(var_num1,var_num2))
	{
	  // this instruction can be shared
	  goto shift_and_insert_shared;      
	}
      else // try to replace this Compare by an equivalent one which is also in _constrIntegrated
	{
	  EqualityConstraint::MergedPairs mergedPairs(_constrOld,var_num1,var_num2);
	  ulong merged1;
	  ulong merged2; 
	  while (mergedPairs.nextPair(merged1,merged2))
	    {
	      ASSERT(merged1 < merged2);     
	      ASSERT(!_constrOld.Equivalent(merged1,merged2));
	      if (_constrIntegrated.Equivalent(merged1,merged2) && (!_constrPassed.Equivalent(merged1,merged2)))
		{
		  // appropriate replacement found
		  var_num1 = merged1;
		  var_num2 = merged2;
		  // modify the arguments of instr
		  instr->setVar1(Var(var_num1));
		  instr->setVar2(Var(var_num2));        
		  goto shift_and_insert_shared;
		};
	    };
      
	  // no appropriate replacement found, must follow the fork

	  if (!_constrToShift.Identity())
	    {
	      _constrPassedInShift = _constrPassed;
	      _constrPassedInShift.MakeEquivalent(var_num1,var_num2);
	      CopyCompsToShift(instr->nextAddr());
	    };
	  MoveRight();  
	  DOP(CheckConstrIntegrity());
	  return false;
	};

    shift_and_insert_shared:
      COP("shift_and_insert_shared");
      // make necessary shifts into the fork
      if (instr->fork()) 
	{
	  if (!_constrToShift.Identity())
	    {
	      _constrPassedInShift = _constrPassed; 
	      CopyCompsToShift(instr->forkAddr());  
	    };      
	};
      ASSERT(instr == (*_nodeAddr));
      _constrPassed.MakeEquivalent(var_num1,var_num2);
      MoveDown();
      instr = *_nodeAddr; 
      // now find all CompareS that can be shared due to (var_num1 ~ var_num2) added to _constrOld
 
    
      EqualityConstraint::MergedPairs mergedPairs(_constrOld,var_num1,var_num2);
      ulong merged1;
      ulong merged2; 

      while (mergedPairs.nextPair(merged1,merged2))
	{
	  ASSERT(merged1 < merged2);     
	  ASSERT(!_constrOld.Equivalent(merged1,merged2));

	  if (_constrIntegrated.Equivalent(merged1,merged2) && (!_constrPassed.Equivalent(merged1,merged2)))
	    {
	      // another Compare can be shared	
	      _constrPassed.MakeEquivalent(merged1,merged2);
	      *_nodeAddr = Instruction::newCompare(Var(merged1),Var(merged2));
	      (*_nodeAddr)->setNext(instr);
	      MoveDown();
	    };
	};    

      ASSERT((*_nodeAddr) == instr);

      _constrOld.MakeEquivalent(var_num1,var_num2); 

      COP("end");
      DOP(CheckConstrIntegrity());     
      return true;
    }; // bool PassComp(Instruction* instr)




  // Read mode
 private:
  bool ReadFunc(const Symbol& func);
  bool ReadVar();
  void ReadCompare(const Flatterm** v1,const Flatterm** v2);
  bool ReadCollectedComps();
    
  // Write mode 
 private:
  void EnterWriteMode();
  void WriteFunc(const Symbol& func);
  void WriteVar(const ulong& v);
  void WriteCompare(const Flatterm** v1,const Flatterm** v2);
  void InsertVar(const Flatterm** v);
  void InsertFunc(const Symbol& func);
      
  // Insertion of constraints 
 private:
  void CopyCompsToShift(Instruction** addr);
  void InsertCompsToShift(Instruction** addr);
  bool MoveCompsToInsert(Instruction**& addr); 


 private: 
#ifndef NO_DEBUG_VIS
  ostream& outputComps(ostream& str) 
    {
      _constrIntegrated.Normalize();
      _constrOld.Normalize();
      _constrPassed.Normalize();
      _constrToShift.Normalize();
      _constrToInsert.Normalize();
      return str << _constrIntegrated << '\n'
		 << _constrOld << '\n'
		 << _constrPassed << '\n'
		 << _constrToShift << '\n'
		 << _constrToInsert << '\n';      

    };
#endif

 private: // data

  Instruction** _nodeAddr;

  EqualityConstraint _constrToInsert;
  EqualityConstraint _constrToShift;
  EqualityConstraint _constrPassed;
   
  EqualityConstraint _constrPassedInShift;
  EqualityConstraint _constrIntegrated;
  EqualityConstraint _constrOld;   

  const Flatterm** _matchingIndexSubstitution;
  
  const Flatterm** _firstVariableOccurence[MaxNumOfVariables];
  BK::MultisetOfVariables<MaxNumOfVariables> _registeredVariables; 
  const Flatterm** _currentMatchingIndexVar;
  bool _readModeFlag;
   

}; // class FMCodeTree<..>::Integrator


}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::PushVar(const Symbol& sym)
{  
  CALL("PushVar(const Symbol& sym)");
  ulong var = sym.var();
  ASSERT(var < MaxNumOfVariables); 

  if (_readModeFlag)
    {
      _readModeFlag = ReadVar();
      ASSERT(debugInSubst(_currentMatchingIndexVar));
      if (_readModeFlag)
	{
	  if (_registeredVariables.Occurences(var)) { ReadCompare(_firstVariableOccurence[var],_currentMatchingIndexVar); }
	  else // first occurence of the variable
	    {
	      _registeredVariables.Register(var);
	      _firstVariableOccurence[var] = _currentMatchingIndexVar;
	    };        
	} 
      else // variable must be inserted 
	{
	  InsertVar(_currentMatchingIndexVar);
	  if (_registeredVariables.Occurences(var))
	    {
	      EnterWriteMode();
	      WriteCompare(_firstVariableOccurence[var],_currentMatchingIndexVar);
	    } 
	  else // first occurence of the variable
	    {
	      _registeredVariables.Register(var);
	      _firstVariableOccurence[var] = _currentMatchingIndexVar;
	      EnterWriteMode();
	    };     
	};
      _currentMatchingIndexVar++;
    }
  else // write mode
    WriteVar(var);          
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::PushVar(const Symbol& sym)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::PushFunc(const Symbol& sym)
{
  CALL("PushFunc(const Symbol& sym)");
  if (_readModeFlag)
    {
      _readModeFlag = ReadFunc(sym);
      if (!_readModeFlag) 
	{
	  InsertFunc(sym);
	  EnterWriteMode(); 
	}; 
    }
  else // write mode
    {
      WriteFunc(sym);
    };   
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::PushFunc(const Symbol& sym)

}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal // objects must be static - too costly constructor
{  
 public:
  Removal(const Flatterm** subst)
    : _constr(),
    _constrPassed(),
    _matchingIndexSubstitution(subst),
    _registeredVariables()   
    {};
  ~Removal() {};

  void init(const Flatterm** subst)
  {
    _constr.init();
    _constrPassed.init();
    _matchingIndexSubstitution = subst;
    _registeredVariables.init();   
  };


  void destroy()
  {
    CALL("destroy()");
    _registeredVariables.destroy();
    _constrPassed.destroy();
    _constr.destroy();
    BK_CORRUPT(*this);
  };


  void Reset(Instruction** n)
    {
      CALL("Reset(Instruction** n)");
      // here *n must be nonnull!
      ASSERT(*n);
      _nodeAddr = n;
      _branchToDestroy = n;
      _constr.Reset();
      _constrPassed.Reset();
      _registeredVariables.Reset();
      _currentMatchingIndexVar = _matchingIndexSubstitution; 
    };
  bool Skip(const Symbol& sym)
    {
      if (sym.isVariable()) { return SkipVar(sym.var()); }
      else return SkipFunc(sym);
    };    
   
  bool SkipFunc(const Symbol& func);
  bool SkipVar(const Symbol& var) { return SkipVar(var.var()); };
  bool SkipComps(); 
  Leaf* GetLeaf() const 
    {
      CALL("GetLeaf()");
      ASSERT((*_nodeAddr)->isLeaf());
      return static_cast<Leaf*>(static_cast<void*>(*_nodeAddr)); 
    };
  Instruction** BranchToDestroy() const { return _branchToDestroy; }; 
  
 private: 
  typedef BK::EquivalenceRelation<MaxTermSize> EqualityConstraint;

 private:
  void MoveDown() { _nodeAddr = (*_nodeAddr)->nextAddr(); };
  void MoveRight() { _nodeAddr = (*_nodeAddr)->forkAddr(); }; 
  ulong VarNum(const Flatterm** v) const { return v - _matchingIndexSubstitution; };   
  bool SkipVar(ulong var);
  bool SkipVar();

 private:
  Instruction** _nodeAddr;
  Instruction** _branchToDestroy;
  EqualityConstraint _constr; 
  EqualityConstraint _constrPassed;

  const Flatterm** _matchingIndexSubstitution;  
  const Flatterm** _firstVariableOccurence[MaxNumOfVariables];
  BK::MultisetOfVariables<MaxNumOfVariables> _registeredVariables; 
  const Flatterm** _currentMatchingIndexVar;

}; // class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal
}; // namespace Gem


//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval"
#endif
#include "debugMacros.hpp"
//=================================================

namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval
{   
 public:
  Retrieval() 
    : backtrack_nodes("Retrieval::backtrack_nodes"),
    backtrack_cursors("Retrieval::backtrack_cursors")
    {
      CALL("constructor Retrieval()");
    };
  ~Retrieval() 
  {
    CALL("destructor ~Retrieval()");
  };
  void init()
  {
    CALL("init()");
    backtrack_nodes.init("Retrieval::backtrack_nodes");
    backtrack_cursors.init("Retrieval::backtrack_cursors");
  };
  
  void destroy()
  {
    CALL("destroy()");
    backtrack_cursors.destroy();
    backtrack_nodes.destroy();
    BK_CORRUPT(*this);
  };

  Leaf* Match(const Flatterm* query,Instruction* tree);
  Leaf* MatchAgain();
    
 private:
  BK::Stack<Instruction*,MaxTermSize> backtrack_nodes;
  BK::Stack<const Flatterm*,MaxTermSize> backtrack_cursors;
}; // template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> class Retrieval

}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output"
#endif
#include "debugMacros.hpp"
//=================================================

namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
class FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output
{  
 public:
  Output()
    : vars(0), 
    _leafInfo(&LeafInfoDefault)
    {};
  ~Output() {};

  void init()
  {
    vars = 0; 
    _leafInfo = &LeafInfoDefault;
  };
  
  void destroy()
  {
    BK_CORRUPT(*this);
  };

  //void Init() { vars = 0; _leafInfo = &LeafInfoDefault; };
 private:
  static void LeafInfoDefault(Instruction* instr); 
  ostream& Var(ostream& str,const Flatterm** v) const { return str << v - vars; };    
 public:
  void SetSubst(const Flatterm* const * subst) { vars = subst; };
  void SetLeafInfo(void (*f)(Instruction* instr)) { _leafInfo = f; };
#ifndef NO_DEBUG_VIS             
  ostream& instruction(ostream& str,const Instruction* node) const
    {
      return node->output(str,vars);
    };
  ostream& Tree(ostream& str,const Instruction* tree) const;    
#endif
 private: 
  const Flatterm* const * vars;
  void (*_leafInfo)(Instruction* instr);
}; // class Output

}; // namespace Gem
//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Destroy(Instruction* tree)
{
  CALL("Destroy(Instruction* tree)");
  if (!tree) return;
  if (!tree->isLeaf())
    {
      COP("fork");
      Destroy(tree->fork());
      COP("next");
      Destroy(tree->next());
    }; 
  delete tree;    
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Destroy(Instruction* tree)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::DestroyBranch(Instruction** branch)
{
  CALL("DestroyBranch(Instruction** branch)");  
  Instruction* _fork;
  
  if ((*branch)->isLeaf()) { _fork = 0; }
  else 
    {
      _fork = (*branch)->fork();
      (*branch)->setFork(0);
    };
  Destroy(*branch);
  *branch = _fork;
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::DestroyBranch(Instruction** branch)
}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipVar(ulong var)
{
  CALL(" FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipVar(ulong var)");
  if (_registeredVariables.Occurences(var))
    {
      _constr.MakeEquivalent(VarNum(_firstVariableOccurence[var]),VarNum(_currentMatchingIndexVar)); 
    }
  else // first occurence
    {
      _registeredVariables.Register(var);
      _firstVariableOccurence[var] = _currentMatchingIndexVar;
    };

  _currentMatchingIndexVar++;

  return SkipVar();    
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipVar(ulong var) 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipVar()
{
  CALL("SkipVar()");
  ASSERT(*_nodeAddr);
  const Flatterm** var1;
  const Flatterm** var2;
  ulong var_num1;
  ulong var_num2;
  Instruction* curr_node;  
 check_node:
  curr_node = *_nodeAddr;
  switch (curr_node->tag())
    {
    case Instruction::FuncTag: return false; // no functor can preceed a variable
     
    case Instruction::VarTag:    
      if (curr_node->fork()) _branchToDestroy = _nodeAddr;
      MoveDown();
      return true;     

    case Instruction::CompareTag:
      curr_node->bothVars(var1,var2);     
      var_num1 = VarNum(var1);
      var_num2 = VarNum(var2);
      if (_constr.Equivalent(var_num1,var_num2))
	{
	  ASSERT(!curr_node->fork());
	  _constrPassed.MakeEquivalent(var_num1,var_num2);
	  MoveDown();
	  goto check_node;
	}       
      else return false;
     
#ifdef DEBUG_NAMESPACE

    default:   
      ICP("ICP0"); return false;
#else 
#ifdef _SUPPRESS_WARNINGS_
    default: return false;
#endif
#endif 
    };
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipVar() 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipFunc(const Symbol& func)
{
  CALL("SkipFunc(const Symbol& func)");
  ASSERT(*_nodeAddr);
  const Flatterm** var1;
  const Flatterm** var2;
  ulong var_num1;
  ulong var_num2;
  Instruction* curr_node;  
 check_node:
  curr_node = *_nodeAddr;
  switch (curr_node->tag())
    {
    case Instruction::FuncTag:
      if (curr_node->func() == func) 
	{
	  if (curr_node->fork()) _branchToDestroy = _nodeAddr;
	  MoveDown();
	  return true;
	};
    try_fork:
      if (curr_node->fork())
        {
	  MoveRight();
	  _branchToDestroy = _nodeAddr;
	  goto check_node;
        }        
      else return false; 

    case Instruction::CompareTag:
      curr_node->bothVars(var1,var2);     
      var_num1 = VarNum(var1);
      var_num2 = VarNum(var2);
      if (_constr.Equivalent(var_num1,var_num2))
	{
	  ASSERT(!curr_node->fork());
	  _constrPassed.MakeEquivalent(var_num1,var_num2);
	  MoveDown();
	  goto check_node;
	}       
      else return false;  

    case Instruction::VarTag: goto try_fork;

#ifdef DEBUG_NAMESPACE
    default: ICP("X0"); return false;
#else 
#ifdef _SUPPRESS_WARNINGS_
    default: return false;
#endif
#endif        
    };  
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipFunc(const Symbol& func)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipComps()
{
  CALL("SkipComps()");
  ASSERT(*_nodeAddr);
  const Flatterm** var1;
  const Flatterm** var2;
  ulong var_num1;
  ulong var_num2;
  Instruction* curr_node;
 check_tag:
  curr_node = *_nodeAddr;
 
  if (curr_node->isCompare())
    {
      curr_node->bothVars(var1,var2);
      var_num1 = VarNum(var1);
      var_num2 = VarNum(var2);
      if (_constr.Equivalent(var_num1,var_num2))
	{
	  _constrPassed.MakeEquivalent(var_num1,var_num2);
	  if (curr_node->fork()) _branchToDestroy = _nodeAddr;       
	  MoveDown();       
	  goto check_tag;
	};
      if (curr_node->fork())
	{
	  MoveRight();
	  _branchToDestroy = _nodeAddr;
	  goto check_tag;
	};
      return false;
    };
  // !curr_node->isCompare()
  _constr.Subtract(_constrPassed);  
  return _constr.Identity();  
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Removal::SkipComps()

}; // namespace Gem


//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{

#ifndef NO_DEBUG_VIS 
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
ostream& FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output::Tree(ostream& str,const Instruction* tree) const
{
  BK::Stack<const Instruction*,MaxTermSize> forks("FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output::Tree(..)::forks");    
 next_node:
  instruction(str,tree) << '\n';
  if (tree->fork()) forks.push(tree);
  tree = tree->next();
  if (tree) goto next_node;
  if (forks.empty()) return str;
  tree = forks.pop();
  str << "fork from [" << (ulong)tree << "]\n";
  tree = tree->fork();
  goto next_node;   
}; // ostream& FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output::Tree(ostream& str,const Instruction* tree) const
#endif
}; // namespace Gem


//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction" 
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{

#ifndef NO_DEBUG_VIS 
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
ostream& FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::output(ostream& str,const Flatterm* const * subst) const
{
  str << '[' << (ulong)this << "] ";
  switch (tag())
    { 
    case VarTag: str << "Var " << var() - subst; break;
    case FuncTag: str << "Func " << func(); break; 
    case CompareTag: str << "Compare " << var1() - subst << ' ' << var2() - subst; break;
    case LeafTag: str << "Leaf "; break;
    };
  str << " n[" << (ulong)next() << "] "
      << " f[" << (ulong)fork() << ']'; 
  return str;
}; // ostream& FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Instruction::output(const Flatterm* const * subst) const
#endif

}; // namespace Gem


//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator"
#endif
#include "debugMacros.hpp"
//=================================================
namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadFunc(const Symbol& sym)
{ 
  CALL("ReadFunc(const Symbol& sym)")
    Instruction* curr_node;  
 check_tag:   
  curr_node = *_nodeAddr; 
  ASSERT(curr_node);
  switch (curr_node->tag())
    {
    case Instruction::FuncTag:  
      if (curr_node->func() == sym)
	{
	  DOP(CheckConstrIntegrity());   
	  if (curr_node->fork()) 
	    {
	      if (!_constrToShift.Identity())  
		{       
		  _constrPassedInShift = _constrPassed; 
		  CopyCompsToShift(curr_node->forkAddr());
		};
	    };
	  MoveDown();
	  return true;
	};
      // different functor
      if (curr_node->func() > sym)
	{
	  if (!_constrToShift.Identity())  
	    {
	      _constrPassedInShift = _constrPassed;
	      InsertCompsToShift(_nodeAddr);
	    };
	  return false;
	};
      // curr_node->func() < sym 
      // no break here! go to the next case

    case Instruction::VarTag:
      // mismatch occured, try fork
      DOP(CheckConstrIntegrity());
      if (curr_node->fork())      
	{
	  if (!_constrToShift.Identity())
	    {
	      _constrPassedInShift = _constrPassed;  
	      CopyCompsToShift(curr_node->nextAddr());
	    };
	  MoveRight();
	  goto check_tag;
	};
      // no more forks

      if (!_constrToShift.Identity())
	{
	  _constrPassedInShift = _constrPassed; 
	  InsertCompsToShift(curr_node->nextAddr());
	};
      MoveRight();
      return false; 

    case Instruction::CompareTag:
      PassCompNF(curr_node);
      goto check_tag;

#ifdef DEBUG_NAMESPACE
    default: ICP("X0"); return false;
#else 
#ifdef _SUPPRESS_WARNINGS_
    default: return false;
#endif
#endif
    };
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadFunc(const Symbol& sym)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadVar()
{
  CALL("ReadVar()");
  Instruction* curr_node;
 check_tag:
  curr_node = *_nodeAddr;        
  switch (curr_node->tag())
    {
    case Instruction::FuncTag:
      // no functor can preceed variable in a tree

      if (!_constrToShift.Identity())
	{
	  _constrPassedInShift = _constrPassed;
	  InsertCompsToShift(_nodeAddr);
	};   
      return false; 

    case Instruction::VarTag:
      DOP(CheckConstrIntegrity());
      if (curr_node->fork()) 
	{
	  if (!_constrToShift.Identity())
	    {
	      _constrPassedInShift = _constrPassed; 
	      CopyCompsToShift(curr_node->forkAddr()); 
	    };
	};              
      MoveDown();
      return true;

    case Instruction::CompareTag:
      PassCompNF(curr_node);
      goto check_tag;

#ifdef DEBUG_NAMESPACE
    default: ICP("X0"); return false;
#else 
#ifdef _SUPPRESS_WARNINGS_
    default: return false;
#endif
#endif
    };  
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadVar() 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadCompare(const Flatterm** v1,const Flatterm** v2)
{
  CALL("ReadCompare(const Flatterm** v1,const Flatterm** v2)");
  ASSERT(v1<v2);  
  ASSERT(debugInSubst(v1));
  ASSERT(debugInSubst(v2));
  ulong var_num1 = VarNum(v1);
  ulong var_num2 = VarNum(v2);
  MakeIntegrated(var_num1,var_num2);
  _constrToInsert.MakeEquivalent(var_num1,var_num2);  
  DOP(CheckConstrIntegrity());
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadCompare(const Flatterm** v1,const Flatterm** v2) 


template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadCollectedComps()
{
  CALL("ReadCollectedComps()");
  ASSERT(_readModeFlag);
  Instruction* curr_node;
 check_node:
  curr_node = *_nodeAddr;
  if (curr_node->isCompare())
    {
      if (PassComp(curr_node) || (*_nodeAddr)) goto check_node;
      DOP(CheckConstrIntegrity());
      MoveCompsToInsert(_nodeAddr);
      _constrToShift.Reset();
      ASSERT(!(*_nodeAddr));
      return false;
    };
   
  // !curr_node->isCompare(), must stop here

  if (_constrToShift.Identity())
    {
      Instruction** _nodeAddrBackup = _nodeAddr;
      *_nodeAddr = 0;
      DOP(CheckConstrIntegrity());
      if (MoveCompsToInsert(_nodeAddr))
	{
	  ASSERT(!(*_nodeAddr));
	  ASSERT((*_nodeAddrBackup)->isCompare());
	  (*_nodeAddrBackup)->setFork(curr_node);
	  return false;
	}
      else // !MoveCompsToInsert(_nodeAddr) (did not insert anything)
	{
	  ASSERT(_nodeAddr == _nodeAddrBackup);
	  ASSERT(!(*_nodeAddr));
	  *_nodeAddr = curr_node;          
	  return true; 
	};      
    }
  else // !_constrToShift.Identity(), simple case
    { 
      _constrPassedInShift = _constrPassed;
      InsertCompsToShift(_nodeAddr);
      ASSERT((*_nodeAddr)->isCompare());       
      ASSERT((!_constrIntegrated.Equivalent(VarNum((*_nodeAddr)->var1()),VarNum((*_nodeAddr)->var2()))));
      MoveRight();
      MoveCompsToInsert(_nodeAddr);
      ASSERT(!(*_nodeAddr));
      return false; 
    };
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::ReadCollectedComps()


template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertVar(const Flatterm** v)
{
  CALL("InsertVar(const Flatterm** v)");
  ASSERT(debugInSubst(v));
  Instruction* tmp = *_nodeAddr;
  *_nodeAddr = Instruction::newVar(v);
  (*_nodeAddr)->setFork(tmp);
  MoveDown(); 
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertVar(const Flatterm** v)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertFunc(const Symbol& func)
{
  Instruction* tmp = *_nodeAddr;
  *_nodeAddr = Instruction::newFunc(func);
  (*_nodeAddr)->setFork(tmp);
  MoveDown();
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertFunc(const Symbol& func)  

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::EnterWriteMode()
{
  CALL("EnterWriteMode()");
  // must be used if ReadVar or ReadFunc failed
  ASSERT(_constrToShift.Identity());

  ASSERT(_constrToInsert.Implies(_constrIntegrated));
  ASSERT(_constrPassed.Implies(_constrIntegrated));
  ASSERT(_constrPassed.Implies(_constrOld));     

  //_constrToInsert.Subtract(_constrPassed);

  MoveCompsToInsert(_nodeAddr);
  ASSERT(!(*_nodeAddr));  
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::EnterWriteMode() 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteVar(const ulong& v)
{
  CALL("WriteVar(const ulong& v)");
  ASSERT(debugInSubst(_currentMatchingIndexVar));
  *_nodeAddr = Instruction::newVar(_currentMatchingIndexVar);
  MoveDown();
  if (_registeredVariables.Occurences(v)) { WriteCompare(_firstVariableOccurence[v],_currentMatchingIndexVar); }
  else // first occurence
    {
      _registeredVariables.Register(v);
      _firstVariableOccurence[v] = _currentMatchingIndexVar;
    };   
  _currentMatchingIndexVar++;
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteVar(ulong v) 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteFunc(const Symbol& func)
{
  *_nodeAddr = Instruction::newFunc(func);
  MoveDown();
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteFunc(const Symbol& func) 


template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteCompare(const Flatterm** v1,const Flatterm** v2)
{
  CALL("WriteCompare(const Flatterm** v1,const Flatterm** v2)");
  ASSERT(debugInSubst(v1));
  ASSERT(debugInSubst(v2));
  *_nodeAddr = Instruction::newCompare(v1,v2); 
  MoveDown();
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::WriteCompare(const Flatterm** v1,const Flatterm** v2)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::CopyCompsToShift(Instruction** addr)
{
  CALL("CopyCompsToShift(Instruction** addr)");
  DOP(bool debugAtLeastOneShifted = _constrToShift.Identity());  
  ASSERT(_constrPassed.Implies(_constrPassedInShift));
  ulong vn1,vn2;

  EqualityConstraint::Iterator iter(_constrToShift);

  Instruction* old_node = *addr;
  Instruction* new_node; 
  while (iter.Next(vn2,vn1))
    {
      ASSERT(vn1<vn2);
      ASSERT(debugInSubst(Var(vn1)));
      ASSERT(debugInSubst(Var(vn2)));
      ASSERT(!_constrIntegrated.Equivalent(vn1,vn2));
      ASSERT(_constrOld.Equivalent(vn1,vn2)); 

      if (!_constrPassedInShift.Equivalent(vn1,vn2))
	{
	  DOP(debugAtLeastOneShifted = true);
	  _constrPassedInShift.MakeEquivalent(vn1,vn2);  
	  new_node = Instruction::newCompare(Var(vn1),Var(vn2));
	  *addr = new_node;
	  addr = new_node->nextAddr(); 
	};
    };
  *addr = old_node;
  ASSERT(debugAtLeastOneShifted);
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::CopyCompsToShift(Instruction** addr)

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertCompsToShift(Instruction** addr)
{
  CALL("InsertCompsToShift(Instruction** addr)");
  DOP(bool debugAtLeastOneShifted = _constrToShift.Identity());  
  DOP(CheckConstrIntegrity());     
  ASSERT(_constrPassed.Implies(_constrPassedInShift));
  ulong vn1,vn2;
  Instruction* old_node = *addr;
  Instruction* new_node; 
  while (_constrToShift.Split(vn2,vn1))
    {    
      ASSERT(vn1<vn2);
      ASSERT(debugInSubst(Var(vn1)));
      ASSERT(debugInSubst(Var(vn2)));

      ASSERT(!_constrIntegrated.Equivalent(vn1,vn2));
      ASSERT(_constrOld.Equivalent(vn1,vn2));

      if (!_constrPassedInShift.Equivalent(vn1,vn2))
	{
	  DOP(debugAtLeastOneShifted = true);  
	  _constrPassedInShift.MakeEquivalent(vn1,vn2);
	  new_node = Instruction::newCompare(Var(vn1),Var(vn2));
	  *addr = new_node;
	  addr = new_node->nextAddr(); 
	};
    };
  ASSERT(_constrToShift.Identity());
  *addr = old_node;
  ASSERT(debugAtLeastOneShifted);
}; // void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::InsertCompsToShift(Instruction** addr)


template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::MoveCompsToInsert(Instruction**& addr)
{
  CALL("MoveCompsToInsert(Instruction**& addr)");
  ulong vn1,vn2;
  Instruction* old_node = *addr;
  Instruction* new_node;
  bool res = false;
  while (_constrToInsert.Split(vn2,vn1))
    {
      ASSERT(vn1<vn2);
      ASSERT(debugInSubst(Var(vn1)));
      ASSERT(debugInSubst(Var(vn2)));
      ASSERT(_constrIntegrated.Equivalent(vn1,vn2));

      if (!_constrPassed.Equivalent(vn1,vn2))
	{
	  ASSERT(!_constrOld.Equivalent(vn1,vn2));
	  _constrPassed.MakeEquivalent(vn1,vn2);
	  new_node = Instruction::newCompare(Var(vn1),Var(vn2));
	  *addr = new_node;
	  addr = new_node->nextAddr(); 
	  res = true;   
	};
    };
  ASSERT(_constrToInsert.Identity());
  *addr = old_node;

  ASSERT(_constrToInsert.Identity());
  ASSERT(_constrPassed.Implies(_constrIntegrated));
  ASSERT(_constrIntegrated.Implies(_constrPassed));
  return res;
}; // bool FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Integrator::MoveCompsToInsert(Instruction**& addr)

}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval"
#endif
#include "debugMacros.hpp"
//=================================================

namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Leaf* FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval::Match(const Flatterm* query,Instruction* tree)
{
  CALL("Match(const Flatterm* query,Instruction* tree)");
  if (!tree) return 0;

  backtrack_nodes.reset();  
  backtrack_cursors.reset();
  
  const Flatterm* cursor = query;
  Instruction* curr_node = tree;
  Symbol curr_sym;

  COP("before check_node");

 check_node:
  COP("check_node");
  ASSERT(curr_node); 
  switch (curr_node->tag()) 
    {
    case Instruction::FuncTag:
      COP("Func");
      curr_sym = cursor->symbolRef();                 
      if (curr_sym.isVariable()) goto backtrack; 
   
    compare_func:
      COP("compare_func");
      if (curr_sym == curr_node->func())
	{
	  cursor = cursor->next();
	  curr_node = curr_node->next();
	  goto check_node;  
        };      
      // different symbols
      if (curr_sym < curr_node->func()) goto backtrack;
      // here curr_sym > curr_node->func()     
      curr_node = curr_node->fork();
      if (!curr_node) goto backtrack;
    func_check_tag:
      COP("func_check_tag");
      if (curr_node->isFunc()) goto compare_func;
      // here curr_node must point to a Compare without fork
      ASSERT(curr_node->isCompare());
      ASSERT(!curr_node->fork());  
      if ((*(curr_node->var1()))->equal(*(curr_node->var2())))
	{
          curr_node = curr_node->next();
          goto func_check_tag;
	}
      else // Compare failed
	goto backtrack;
                
    case Instruction::VarTag:
      COP("VAR");
      *(curr_node->var()) = cursor;        
      if (curr_node->fork() && cursor->symbolRef().isNotVariable())
	{
	  backtrack_nodes.push(curr_node->fork());
	  backtrack_cursors.push(cursor);
	};
      cursor = cursor->after();
      curr_node = curr_node->next();
      goto check_node;     

    case Instruction::CompareTag:
      COP("Compare");
      if ((*(curr_node->var1()))->equal(*(curr_node->var2())))
	{
	  if (curr_node->fork())
	    {
	      backtrack_nodes.push(curr_node->fork());
	      backtrack_cursors.push(cursor);
	    };
	  curr_node = curr_node->next();
	  goto check_node;
	}
      else // Compare failed, try fork
	{
	  curr_node = curr_node->fork();
	  if (curr_node) goto check_node;
	  goto backtrack;
	};

    case Instruction::LeafTag:
      COP("Leaf"); 
      return static_cast<Leaf*>(static_cast<void*>(curr_node)); // success

#ifdef DEBUG_NAMESPACE
    default: COP("default1"); ICP("X0"); return 0;
#else
#ifdef _SUPPRESS_WARNINGS_
    default: COP("default2"); return 0;  
#endif
#endif
    };
 
  //*************** Backtrack section: **********
  COP("before bakctrack");
 backtrack:
  COP("backtrack");
  BK::GlobalStopFlag::check();
  if (backtrack_nodes.empty())
    {   
      // failure
      return 0;
    };
  curr_node = backtrack_nodes.pop(); 
  cursor = backtrack_cursors.pop();
  goto check_node;
}; // Leaf* FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval::Match(const Flatterm* query,Instruction* tree) 

template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
inline FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Leaf* FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval::MatchAgain()
{
  CALL("MatchAgain()");
  const Flatterm* cursor;
  Instruction* curr_node;
  Symbol curr_sym;

  goto backtrack;

 check_node:
  COP("check_node");
  ASSERT(curr_node); 
  switch (curr_node->tag()) 
    {
    case Instruction::FuncTag:
      COP("FUNC");
      curr_sym = cursor->symbolRef();                 
      if (curr_sym.isVariable()) goto backtrack; 
   
    compare_func:
      COP("compare_func");
      if (curr_sym == curr_node->func())
	{
	  cursor = cursor->next();
	  curr_node = curr_node->next();
	  goto check_node;  
        };      
      // different symbols
      if (curr_sym < curr_node->func()) goto backtrack;
      // here curr_sym > curr_node->func()     
      curr_node = curr_node->fork();
      if (!curr_node) goto backtrack;
    func_check_tag:
      COP("func_check_tag");
      if (curr_node->isFunc()) goto compare_func;
      // here curr_node must point to a Compare without fork
      ASSERT(curr_node->isCompare());
      ASSERT(!curr_node->fork());  
      if ((*(curr_node->var1()))->equal(*(curr_node->var2())))
	{
          curr_node = curr_node->next();
          goto func_check_tag;
	}
      else // Compare failed
	goto backtrack;
                
    case Instruction::VarTag:
      COP("VAR");
      *(curr_node->var()) = cursor;        
      if (curr_node->fork() && cursor->symbolRef().isNotVariable())
	{
	  backtrack_nodes.push(curr_node->fork());
	  backtrack_cursors.push(cursor);
	};
      cursor = cursor->after();
      curr_node = curr_node->next();
      goto check_node;     

    case Instruction::CompareTag:
      COP("Compare");
      if ((*(curr_node->var1()))->equal(*(curr_node->var2())))
	{
	  if (curr_node->fork())
	    {
	      backtrack_nodes.push(curr_node->fork());
	      backtrack_cursors.push(cursor);
	    };
	  curr_node = curr_node->next();
	  goto check_node;
	}
      else // Compare failed, try fork
	{
	  curr_node = curr_node->fork();
	  if (curr_node) goto check_node;
	  goto backtrack;
	};

    case Instruction::LeafTag: 
      COP("Leaf"); 
      return  static_cast<Leaf*>(static_cast<void*>(curr_node)); // success

#ifdef DEBUG_NAMESPACE
    default: COP("default1"); ICP("X0"); return 0;
#else
#ifdef _SUPPRESS_WARNINGS_
    default: COP("default2"); return 0;  
#endif
#endif
    };
 
  //*************** Backtrack section: **********
  COP("before bakctrack");
 backtrack:
  COP("backtrack");
  if (backtrack_nodes.empty())
    {
      // failure
      return 0;
    };
  curr_node = backtrack_nodes.pop(); 
  cursor = backtrack_cursors.pop();
  goto check_node;
}; // Leaf* FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Retrieval::MatchAgain()

}; // namespace Gem

//================================================
#undef DEBUG_NAMESPACE
#ifdef DEBUG_FORWARD_MATCHING_INDEX_TREE
#define DEBUG_NAMESPACE "FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output"
#endif
#include "debugMacros.hpp"
//=================================================

namespace Gem
{
template <ulong MaxTermSize,ulong MaxNumOfVariables,class Alloc,class Symbol,class Flatterm,class LeafInfo,class InstanceId> 
void FMCodeTree<MaxTermSize,MaxNumOfVariables,Alloc,Symbol,Flatterm,LeafInfo,InstanceId>::Output::LeafInfoDefault(Instruction* instr) {}; 

}; // namespace Gem

//=============================================================
#endif

